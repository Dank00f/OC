#include <bits/stdc++.h>
#include <chrono>
#include <ctime>
#include <iomanip>
#include <random>
#include <string>
#include <sstream>
#include <thread>

using namespace std;

// Парс/формат времени (UTC)
static time_t parse_iso_utc(const string& iso) {
    // формат: YYYY-MM-DDTHH:MM:SSZ
    tm t{}; 
    if (iso.size() < 20 || iso[4] != '-' || iso[7] != '-' || iso[10] != 'T' || iso[13] != ':' || iso[16] != ':' || iso.back() != 'Z')
        return (time_t)-1;
    t.tm_year = stoi(iso.substr(0,4)) - 1900;
    t.tm_mon  = stoi(iso.substr(5,2)) - 1;
    t.tm_mday = stoi(iso.substr(8,2));
    t.tm_hour = stoi(iso.substr(11,2));
    t.tm_min  = stoi(iso.substr(14,2));
    t.tm_sec  = stoi(iso.substr(17,2));
    t.tm_isdst = 0;
    // timegm — UTC
    #if defined(_BSD_SOURCE) || defined(_SVID_SOURCE) || defined(_GNU_SOURCE)
        return timegm(&t);
    #else
        // portable fallback
        char *tz = getenv("TZ");
        setenv("TZ","UTC",1); tzset();
        time_t tt = mktime(&t);
        if (tz) setenv("TZ", tz, 1); else unsetenv("TZ");
        tzset();
        return tt;
    #endif
}

static string iso_utc_from(time_t tt) {
    tm t{}; gmtime_r(&tt, &t);
    ostringstream os;
    os << put_time(&t, "%Y-%m-%dT%H:%M:%SZ");
    return os.str();
}

static time_t floor_hour(time_t tt) {
    return (tt / 3600) * 3600;
}
static time_t floor_day (time_t tt) {
    return (tt / 86400) * 86400;
}

struct Acc {
    double sum = 0.0;
    size_t n = 0;
    void add(double x){ sum += x; ++n; }
    double avg() const { return n ? (sum / n) : numeric_limits<double>::quiet_NaN(); }
    void reset(){ sum = 0.0; n = 0; }
};

int main(int argc, char** argv) {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string logDir = "./logs";
    bool simulate = false;

    // аргументы
    for (int i=1;i<argc;i++){
        string a = argv[i];
        if (a == "--log-dir" && i+1<argc) { logDir = argv[++i]; }
        else if (a == "--simulate") { simulate = true; }
    }

    // файлы
    string f_meas   = logDir + "/measurements.log";
    string f_hourly = logDir + "/hourly_avg.log";
    string f_daily  = logDir + "/daily_avg.log";

    // создаём каталог
    system((string("mkdir -p ") + logDir).c_str());

    // открываем на дозапись
    ofstream meas(f_meas, ios::app);
    ofstream hourly(f_hourly, ios::app);
    ofstream daily(f_daily, ios::app);

    if (!meas)  { cerr << "cannot open " << f_meas   << "\n"; return 1; }
    if (!hourly){ cerr << "cannot open " << f_hourly << "\n"; return 1; }
    if (!daily) { cerr << "cannot open " << f_daily  << "\n"; return 1; }

    // Аккумуляторы
    Acc acc_hour, acc_day;
    bool have_hour=false, have_day=false;
    time_t cur_hour = -1;
    time_t cur_day  = -1;

    auto roll_hour = [&](time_t hour_start){
        if (acc_hour.n == 0) return;
        // пишем среднее за предыдущий час, помечаем строкой начала часа
        hourly << iso_utc_from(hour_start) << "," << fixed << setprecision(3) << acc_hour.avg() << "\n";
        hourly.flush();
        acc_hour.reset();
    };
    auto roll_day = [&](time_t day_start){
        if (acc_day.n == 0) return;
        daily << iso_utc_from(day_start) << "," << fixed << setprecision(3) << acc_day.avg() << "\n";
        daily.flush();
        acc_day.reset();
    };

    auto feed_sample = [&](const string& ts_iso, double temp){
        // пишем измерение
        meas << ts_iso << "," << fixed << setprecision(3) << temp << "\n";
        meas.flush();

        // время метки
        time_t tt = parse_iso_utc(ts_iso);
        if (tt == (time_t)-1) return;

        time_t h = floor_hour(tt);
        time_t d = floor_day(tt);

        // если это первый сэмпл — инициализация окна
        if (!have_hour) { cur_hour = h; have_hour = true; }
        if (!have_day ) { cur_day  = d; have_day  = true; }

        // сменился день? сначала закрываем час (если как-то сдвинулся), затем день
        if (d != cur_day) {
            // закрываем последний час предыдущего дня
            if (h != cur_hour) {
                roll_hour(cur_hour);
                cur_hour = h;
            }
            roll_day(cur_day);
            cur_day = d;
        }

        // сменился час?
        if (h != cur_hour) {
            roll_hour(cur_hour);
            cur_hour = h;
        }

        // накапливаем
        acc_hour.add(temp);
        acc_day.add(temp);
    };

    if (simulate) {
        // эмулятор: генерируем ~5 Гц температуру
        mt19937_64 rng{1234567};
        normal_distribution<double> base(23.5, 0.9);
        uniform_real_distribution<double> noise(-0.8, 0.8);

        // стартовое «виртуальное» время берём из реальной now()
        // но для libfaketime это уже будет подменённое
        for (;;) {
            auto now = chrono::system_clock::now();
            time_t tt = chrono::system_clock::to_time_t(now);
            string ts = iso_utc_from(tt);

            double temp = round((base(rng) + noise(rng))*1000.0)/1000.0;
            feed_sample(ts, temp);

            this_thread::sleep_for(chrono::milliseconds(200));
        }
    } else {
        // чтение из stdin строк вида: ISO8601,temp
        string line;
        while (getline(cin, line)) {
            if (line.empty()) continue;
            auto pos = line.find(',');
            if (pos == string::npos) continue;
            string ts = line.substr(0,pos);
            double val = atof(line.c_str()+pos+1);
            feed_sample(ts, val);
        }
    }
    return 0;
}
